// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuditLogEvent = `-- name: CreateAuditLogEvent :one
INSERT INTO audit_log_events (event_type, event_data)
VALUES ($1, $2)
RETURNING id
`

type CreateAuditLogEventParams struct {
	EventType string            `db:"event_type" json:"event_type"`
	EventData AuditLogEventData `db:"event_data" json:"event_data"`
}

// Creates a new audit log event with the given type and data.
//
//	INSERT INTO audit_log_events (event_type, event_data)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) CreateAuditLogEvent(ctx context.Context, arg CreateAuditLogEventParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAuditLogEvent, arg.EventType, arg.EventData)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, username)
VALUES ($1, $2)
RETURNING id, username, created_at, updated_at
`

type CreateUserParams struct {
	ID       pgtype.UUID `db:"id" json:"id"`
	Username string      `db:"username" json:"username"`
}

// Creates a new user with the given ID and username.
//
//	INSERT INTO users (id, username)
//	VALUES ($1, $2)
//	RETURNING id, username, created_at, updated_at
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.ID, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUserEmail = `-- name: CreateUserEmail :exec
INSERT INTO user_emails (id, email, verified, is_primary)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id, email) DO UPDATE
    SET
        verified = excluded.verified,
        is_primary = excluded.is_primary
`

type CreateUserEmailParams struct {
	ID        pgtype.UUID `db:"id" json:"id"`
	Email     string      `db:"email" json:"email"`
	Verified  bool        `db:"verified" json:"verified"`
	IsPrimary bool        `db:"is_primary" json:"is_primary"`
}

// Creates a new user email with the given ID and email address.
//
//	INSERT INTO user_emails (id, email, verified, is_primary)
//	VALUES ($1, $2, $3, $4)
//	ON CONFLICT (id, email) DO UPDATE
//	    SET
//	        verified = excluded.verified,
//	        is_primary = excluded.is_primary
func (q *Queries) CreateUserEmail(ctx context.Context, arg CreateUserEmailParams) error {
	_, err := q.db.Exec(ctx, createUserEmail,
		arg.ID,
		arg.Email,
		arg.Verified,
		arg.IsPrimary,
	)
	return err
}

const createUserPassword = `-- name: CreateUserPassword :exec
INSERT INTO user_passwords (id, password)
VALUES ($1, $2)
ON CONFLICT (id) DO UPDATE
    SET password = excluded.password
`

type CreateUserPasswordParams struct {
	ID       pgtype.UUID `db:"id" json:"id"`
	Password string      `db:"password" json:"password"`
}

// Creates a new user password with the given ID and password hash.
//
//	INSERT INTO user_passwords (id, password)
//	VALUES ($1, $2)
//	ON CONFLICT (id) DO UPDATE
//	    SET password = excluded.password
func (q *Queries) CreateUserPassword(ctx context.Context, arg CreateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, createUserPassword, arg.ID, arg.Password)
	return err
}

const createUserRole = `-- name: CreateUserRole :exec
INSERT INTO user_roles (id, role)
VALUES ($1, $2)
ON CONFLICT (id, role) DO NOTHING
`

type CreateUserRoleParams struct {
	ID   pgtype.UUID `db:"id" json:"id"`
	Role string      `db:"role" json:"role"`
}

// Creates a new user role with the given ID and role name.
//
//	INSERT INTO user_roles (id, role)
//	VALUES ($1, $2)
//	ON CONFLICT (id, role) DO NOTHING
func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) error {
	_, err := q.db.Exec(ctx, createUserRole, arg.ID, arg.Role)
	return err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO user_sessions (id, session_token, expiry)
VALUES ($1, $2, $3)
RETURNING id, session_token, expiry
`

type CreateUserSessionParams struct {
	ID           pgtype.UUID        `db:"id" json:"id"`
	SessionToken string             `db:"session_token" json:"session_token"`
	Expiry       pgtype.Timestamptz `db:"expiry" json:"expiry"`
}

type CreateUserSessionRow struct {
	ID           pgtype.UUID        `db:"id" json:"id"`
	SessionToken string             `db:"session_token" json:"session_token"`
	Expiry       pgtype.Timestamptz `db:"expiry" json:"expiry"`
}

// Creates a new user session with the given ID and session token.
//
//	INSERT INTO user_sessions (id, session_token, expiry)
//	VALUES ($1, $2, $3)
//	RETURNING id, session_token, expiry
func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (*CreateUserSessionRow, error) {
	row := q.db.QueryRow(ctx, createUserSession, arg.ID, arg.SessionToken, arg.Expiry)
	var i CreateUserSessionRow
	err := row.Scan(&i.ID, &i.SessionToken, &i.Expiry)
	return &i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

// Deletes a user with the given ID.
//
//	DELETE FROM users
//	WHERE id = $1
func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    users.id,
    users.username,
    users.created_at,
    users.updated_at
FROM users
WHERE users.id = $1
`

// Gets a user by their ID.
//
//	SELECT
//	    users.id,
//	    users.username,
//	    users.created_at,
//	    users.updated_at
//	FROM users
//	WHERE users.id = $1
func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUserByToken = `-- name: GetUserByToken :one
SELECT
    users.id,
    users.username,
    ARRAY_AGG(user_roles.role)::TEXT [] AS roles
FROM user_sessions
INNER JOIN users ON user_sessions.id = users.id
INNER JOIN user_roles ON users.id = user_roles.id
WHERE user_sessions.session_token = $1
GROUP BY users.id, users.username
`

type GetUserByTokenRow struct {
	ID       pgtype.UUID `db:"id" json:"id"`
	Username string      `db:"username" json:"username"`
	Roles    []string    `db:"roles" json:"roles"`
}

// Gets a user by one of their session tokens.
//
//	SELECT
//	    users.id,
//	    users.username,
//	    ARRAY_AGG(user_roles.role)::TEXT [] AS roles
//	FROM user_sessions
//	INNER JOIN users ON user_sessions.id = users.id
//	INNER JOIN user_roles ON users.id = user_roles.id
//	WHERE user_sessions.session_token = $1
//	GROUP BY users.id, users.username
func (q *Queries) GetUserByToken(ctx context.Context, sessionToken string) (*GetUserByTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserByToken, sessionToken)
	var i GetUserByTokenRow
	err := row.Scan(&i.ID, &i.Username, &i.Roles)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT
    users.id,
    users.username,
    users.created_at,
    users.updated_at
FROM users
WHERE users.username = $1
`

// Gets a user by their username.
//
//	SELECT
//	    users.id,
//	    users.username,
//	    users.created_at,
//	    users.updated_at
//	FROM users
//	WHERE users.username = $1
func (q *Queries) GetUserByUsername(ctx context.Context, username string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUserWithOptionalPasswordByUsername = `-- name: GetUserWithOptionalPasswordByUsername :one
SELECT
    users.id,
    user_passwords.password
FROM users
LEFT JOIN user_passwords ON users.id = user_passwords.id
WHERE users.username = $1
`

type GetUserWithOptionalPasswordByUsernameRow struct {
	ID       pgtype.UUID `db:"id" json:"id"`
	Password *string     `db:"password" json:"password"`
}

// Gets a user by their username, optionally including their password hash.
//
//	SELECT
//	    users.id,
//	    user_passwords.password
//	FROM users
//	LEFT JOIN user_passwords ON users.id = user_passwords.id
//	WHERE users.username = $1
func (q *Queries) GetUserWithOptionalPasswordByUsername(ctx context.Context, username string) (*GetUserWithOptionalPasswordByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserWithOptionalPasswordByUsername, username)
	var i GetUserWithOptionalPasswordByUsernameRow
	err := row.Scan(&i.ID, &i.Password)
	return &i, err
}
